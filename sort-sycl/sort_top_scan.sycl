    //__local int s_seed;
    s_seed[0] = 0; 
	  item.barrier(access::fence_space::local_space);

    // Decide if this is the last thread that needs to
    // propagate the seed value
    int last_thread = (item.get_local_id(0) < num_work_groups &&
                      (item.get_local_id(0)+1) == num_work_groups) ? 1 : 0;

    for (int d = 0; d < 16; d++)
    {
        T val = 0;
        // Load each block's count for digit d
        if (item.get_local_id(0) < num_work_groups)
        {
            val = isums[(num_work_groups * d) + item.get_local_id(0)];
        }
        // Exclusive scan the counts in local memory
        //FPTYPE res = scanLocalMem(val, lmem, 1);
            int idx = item.get_local_id(0);
            lmem[idx] = 0;
            idx += item.get_local_range(0);
            lmem[idx] = val;
            item.barrier(access::fence_space::local_space);
            T t;
            for (int i = 1; i < item.get_local_range(0); i *= 2)
            {
                t = lmem[idx -  i]; 
                item.barrier(access::fence_space::local_space);
                lmem[idx] += t;     
                item.barrier(access::fence_space::local_space);
            }
            T res = lmem[idx-1];

        // Write scanned value out to global
        if (item.get_local_id(0) < num_work_groups)
        {
            isums[(num_work_groups * d) + item.get_local_id(0)] = res + s_seed[0];
        }
	      item.barrier(access::fence_space::local_space);

        if (last_thread)
        {
            s_seed[0] += res + val;
        }
        item.barrier(access::fence_space::local_space);
    }

